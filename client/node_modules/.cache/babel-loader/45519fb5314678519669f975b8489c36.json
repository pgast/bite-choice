{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport { describe, PropTypes } from 'react-desc';\nimport { genericProps } from '../../utils/prop-types';\nimport { getAvailableAtBadge } from '../../utils/mixins';\nvar sizes = ['xxsmall', 'xsmall', 'small', 'medium', 'large', 'xlarge'];\nvar sides = ['horizontal', 'vertical', 'top', 'bottom', 'left', 'right'];\nvar parts = ['header', 'body', 'footer'];\nvar padShapeSides = {};\nsides.forEach(function (side) {\n  padShapeSides[side] = PropTypes.oneOfType([PropTypes.oneOf(sizes), PropTypes.string]);\n});\nvar padShapeParts = {};\nparts.forEach(function (part) {\n  padShapeParts[part] = {};\n  sides.forEach(function (side) {\n    padShapeParts[part][side] = PropTypes.oneOf(sizes);\n  });\n});\nvar backgroundShape = {};\n[].concat(parts, ['pinned']).forEach(function (part) {\n  backgroundShape[part] = PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    dark: PropTypes.string,\n    light: PropTypes.string\n  }), PropTypes.arrayOf(PropTypes.string)]);\n});\nvar borderTypes = [PropTypes.bool, PropTypes.oneOf(sides), PropTypes.shape({\n  color: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    dark: PropTypes.string,\n    light: PropTypes.string\n  })]),\n  side: PropTypes.oneOf(sides),\n  size: PropTypes.oneOfType([PropTypes.oneOf(sizes), PropTypes.string])\n})];\nvar borderShape = {};\nparts.forEach(function (part) {\n  borderShape[part] = PropTypes.oneOfType(borderTypes);\n});\nexport var doc = function doc(DataTable) {\n  var DocumentedDataTable = describe(DataTable).availableAt(getAvailableAtBadge('DataTable', 'Visualizations')).description('A data driven table.').usage(\"import { DataTable } from 'grommet';\\n<DataTable />\").intrinsicElement('table');\n  DocumentedDataTable.propTypes = _extends({}, genericProps, {\n    background: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string), PropTypes.shape(backgroundShape)]).description(\"Cell background. You can set the background per context by passing an\\n      object with keys for 'heading', 'body', and/or 'footer'. If you pass\\n      an array, rows will cycle between the array values.\"),\n    border: PropTypes.oneOfType([].concat(borderTypes, [PropTypes.shape(borderShape)])).description(\"Cell border. You can set the border per context by passing an\\n      object with keys for 'heading', 'body', and/or 'footer'.\"),\n    columns: PropTypes.arrayOf(PropTypes.shape({\n      align: PropTypes.oneOf(['center', 'start', 'end']),\n      aggregate: PropTypes.oneOf(['avg', 'max', 'min', 'sum']),\n      footer: PropTypes.oneOfType([PropTypes.node, PropTypes.shape({\n        aggregate: PropTypes.bool\n      })]),\n      header: PropTypes.oneOfType([PropTypes.string, PropTypes.node, PropTypes.shape({\n        aggregate: PropTypes.bool\n      })]),\n      pin: PropTypes.bool,\n      primary: PropTypes.bool,\n      property: PropTypes.string.isRequired,\n      render: PropTypes.func,\n      search: PropTypes.bool,\n      sortable: PropTypes.bool,\n      size: PropTypes.oneOfType([PropTypes.oneOf(['small', 'medium', 'large', 'xlarge', '1/2', '1/4', '2/4', '3/4', '1/3', '2/3']), PropTypes.string]),\n      units: PropTypes.string,\n      verticalAlign: PropTypes.oneOf(['middle', 'top', 'bottom'])\n    })).description(\"A description of the data. The order controls the column order.\\n      'property' indicates which property in the data objects to associate\\n      the column with. 'header' indicates what to display in the column\\n      header. 'render' allows for custom rendering of body cells. Use 'render'\\n      for custom formatting for things like currency and date or to\\n      display rich content like Meters. 'align' indicates how the cells in\\n      the column are aligned. 'aggregate' indicates how the data in the\\n      column should be aggregated. This only applies to a footer or groupBy\\n      context. 'footer' indicates what should be shown in the footer for\\n      the column. 'search' indicates whether a search filter should be\\n      made available for the column. 'primary' indicates that this property\\n      should be used as the unique identifier, which gives the cell 'row' scope\\n      for accessibility. If 'primary' is not used for any column, and\\n      'primaryKey' isn't specified either, then the first column will be used.\\n      'pin' indicates that this column should not scroll out of view\\n      to the left when the table is scrolled horizontally.\"),\n    data: PropTypes.arrayOf(PropTypes.shape({})).description('Array of data objects.'),\n    fill: PropTypes.oneOfType([PropTypes.oneOf(['horizontal', 'vertical']), PropTypes.bool]).description('Whether the width and/or height should fill the container.'),\n    groupBy: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n      property: PropTypes.string,\n      expand: PropTypes.arrayOf(PropTypes.string),\n      onExpand: PropTypes.func\n    })]).description(\"Property to group data by. If object is specified\\n      'property' is used to group data by, 'expand' accepts array of \\n       group keys that sets expanded groups and 'onExpand' is a function\\n       that will be called after expand button is clicked with\\n       an array of keys of expanded groups.\"),\n    onClickRow: PropTypes.func.description(\"When supplied, this function will be called with an event object that\\n      include a 'datum' property containing the data value associated with\\n      the clicked row. You should not include interactive elements, like\\n      Anchor or Button inside table cells as that can cause confusion with\\n      overlapping interactive elements.\"),\n    onMore: PropTypes.func.description(\"Use this to indicate that 'data' doesn't contain all that it could.\\n      It will be called when all of the data rows have been rendered.\\n      This might be used when the total number of items that could be retrieved\\n      is more than you'd want to load into the browser. 'onMore' allows you\\n      to lazily fetch more from the server only when needed. This cannot\\n      be combined with properties that expect all data to be present in the\\n      browser, such as columns.search, sortable, groupBy, or \\n      columns.aggregate.\"),\n    onSearch: PropTypes.func.description(\"When supplied, and when at least one column has 'search' enabled,\\n      this function will be called with an object with keys for property\\n      names and values which are the search text strings. This is typically\\n      employed so a back-end can be used to search through the data.\"),\n    onSelect: PropTypes.func.description(\"When supplied, causes checkboxes to be added to each row such that\\n      the user can indicate which rows should be selected. This function\\n      will be called with an array of primary key values, suitable to be\\n      passed to the 'select' property. If you are storing select state via\\n      a 'useState' hook, you can do something like:\\n      '<DataTable select={select} onSelect={setSelect} />'.\"),\n    onSort: PropTypes.func.description(\"When supplied, this function will be called with an object\\n      with a 'property' property that indicates which property\\n      is being sorted on and a 'direction' property that will either be\\n      'asc' or 'desc'. onSort={({ property, direction }) => {}}\"),\n    pad: PropTypes.oneOfType([PropTypes.oneOf(sizes), PropTypes.string, PropTypes.shape(padShapeSides), PropTypes.shape(padShapeParts)]).description(\"Cell padding. You can set the padding per context by passing an\\n      object with keys for 'heading', 'body', and/or 'footer'.\"),\n    pin: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['header', 'footer'])]).description(\"Whether the header and/or footer should be pinned when\\n      not all rows are visible. A value of true pins both header and footer.\"),\n    placeholder: PropTypes.oneOfType([PropTypes.string, PropTypes.node]).description(\"A text message or any content to place over the table body.\\n      For example, to say \\\"loading ...\\\" when waiting for data to arrive.\"),\n    primaryKey: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]).description(\"When supplied, indicates the property for a data object to use to\\n      get a unique identifier. See also the 'columns.primary' description.\\n      Use this property when the columns approach will not work for your\\n      data set. Setting primaryKey to false indicates there should be no\\n      unique identifier, avoid this as it's less accessible.\"),\n    replace: PropTypes.bool.description(\"Whether to replace previously rendered items with a generic spacing\\n      element when they have scrolled out of view. This is more performant but\\n      means that in-page searching will not find elements that have been\\n      replaced.\"),\n    resizeable: PropTypes.bool.description('Whether to allow the user to resize column widths.'),\n    rowProps: PropTypes.shape({}).description(\"Row specific background, border, and pad, keyed by primary key value.\\n      For example:\\n      { \\\"primary-key-value\\\": { background: ..., border: ..., pad: ... }},\\n      where the background, border, and pad accept the same values as\\n      the same named properties on DataTable.\"),\n    select: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).description(\"When supplied, causes checkboxes to be added to each row to indicate\\n      which rows are selected. The values in this array should match\\n      the 'primaryKey' or 'columns[].primary' keyed value for the row's data\\n      object. If 'onSelect' is provided, the CheckBoxes are enabled\\n      and this function can be used to track select changes.\"),\n    size: PropTypes.oneOfType([PropTypes.oneOf(['small', 'medium', 'large', 'xlarge']), PropTypes.string]).description(\"The height of the table body. If set, the table body will have a fixed\\n      height and the rows will be scrollable within it. In order to preserve\\n      header and footer cell alignment, all cells will have the same\\n      width. This cannot be used in combination with 'resizeable'.\"),\n    sort: PropTypes.shape({\n      direction: PropTypes.oneOf(['asc', 'desc']),\n      external: PropTypes.bool,\n      property: PropTypes.string.isRequired\n    }).description(\"Which property to sort on and which direction to sort. When 'external'\\n      is true, it indicates that the caller will take care of sorting\\n      the 'data' via 'onSort'. Otherwise, the existing data will be sorted\\n      within DataTable.\"),\n    sortable: PropTypes.bool.description('Whether to allow the user to sort columns.'),\n    step: PropTypes.number.description('How many items to render at a time.').defaultValue(50)\n  });\n  return DocumentedDataTable;\n};\nexport var themeDoc = {\n  'global.hover.background': {\n    description: 'The background style when hovering over an interactive row.',\n    type: 'string | { color: string, opacity: string }',\n    defaultValue: \"{ color: 'active', opacity: 'medium' }\"\n  },\n  'global.hover.color': {\n    description: 'The text color when hovering over an interactive row.',\n    type: 'string | { dark: string, light: string }',\n    defaultValue: \"{ dark: 'white', light: 'black' }\"\n  },\n  'dataTable.body.extend': {\n    description: 'Any additional style for an DataTable Body',\n    type: 'string | (props) => {}',\n    defaultValue: undefined\n  },\n  'dataTable.groupHeader.background': {\n    description: 'The background color of the group header.',\n    type: 'string | { dark: string, light: string }',\n    defaultValue: \"{ dark: 'dark-2', light: 'light-2' }\"\n  },\n  'dataTable.groupHeader.border.side': {\n    description: 'The border side rendered for the group header.',\n    type: 'string',\n    defaultValue: 'bottom'\n  },\n  'dataTable.groupHeader.border.size': {\n    description: 'The border size of the group header border.',\n    type: 'string',\n    defaultValue: 'xsmall'\n  },\n  'dataTable.groupHeader.fill': {\n    description: 'Whether the height should fill the group header.',\n    type: 'string',\n    defaultValue: 'vertical'\n  },\n  'dataTable.groupHeader.pad': {\n    description: 'The pad used for the group header.',\n    type: 'string | object',\n    defaultValue: \"{ horizontal: 'small', vertical: 'xsmall' }\"\n  },\n  'dataTable.header': {\n    description: 'Styles for the header.',\n    type: 'object',\n    defaultValue: '{}'\n  },\n  'dataTable.header.background': {\n    description: 'Any valid Box background value.',\n    type: \"string | \\n    { dark: string, light: string } |\\n    { \\n      color: { dark: string, light: string } | string, \\n      dark: bool, \\n      image: string, \\n      position: string, \\n      opacity: bool | string, \\n      repeat: no-repeat | repeat, \\n      size: cover | contain | string\\n    }\",\n    defaultValue: undefined\n  },\n  'dataTable.header.border': {\n    description: 'Any valid Box border value.',\n    type: 'string | object',\n    defaultValue: undefined\n  },\n  'dataTable.header.color': {\n    description: 'The label and icon color in a header cell.',\n    type: '{ dark: string, light: string } | string',\n    defaultValue: undefined\n  },\n  'dataTable.header.extend': {\n    description: 'Any additional styles for header cells.',\n    type: 'string | (props) => {}',\n    defaultValue: undefined\n  },\n  'dataTable.header.font.weight': {\n    description: 'The font weight for text in header cells.',\n    type: 'string',\n    defaultValue: undefined\n  },\n  'dataTable.header.font.size': {\n    description: 'The font size for text in header cells.',\n    type: 'string',\n    defaultValue: undefined\n  },\n  'dataTable.header.gap': {\n    description: 'The gap between elements within the header cell.',\n    type: 'object',\n    defaultValue: 'small'\n  },\n  'dataTable.header.hover.background': {\n    description: \"The hover background color of the header cell contents, if \\n    clickable. Any valid Box background options apply.\",\n    type: \"string | \\n    { dark: string, light: string } |\\n    { \\n      color: { dark: string, light: string } | string, \\n      dark: bool, \\n      image: string, \\n      position: string, \\n      opacity: bool | string, \\n      repeat: no-repeat | repeat, \\n      size: cover | contain | string\\n    }\",\n    defaultValue: undefined\n  },\n  'dataTable.header.pad': {\n    description: 'The pad around the contents of the header cell.',\n    type: 'string | object',\n    defaultValue: undefined\n  },\n  'dataTable.header.units': {\n    description: \"Any Text component properties for styling the\\n    header's units text.\",\n    type: 'object',\n    defaultValue: \"{\\n  color: \\\"text-xweak\\\",\\n  margin: { left: \\\"xsmall\\\" }\\n}\"\n  },\n  'dataTable.resize.hover.color': {\n    description: 'The color of the resizer when hovered over.',\n    type: 'string | object',\n    defaultValue: undefined\n  },\n  'dataTable.resize.hover.side': {\n    description: \"The side of the resizer when hovered over. If color or size \\n    are defined, this will default to 'end' which is the recommended value.\",\n    type: 'string',\n    defaultValue: undefined\n  },\n  'dataTable.resize.hover.size': {\n    description: \"The size of the resizer when hovered over. Size values \\n    correspond with those accepted by Box border.\",\n    type: 'string',\n    defaultValue: undefined\n  },\n  'dataTable.icons.ascending': {\n    description: 'The ascending icon.',\n    type: 'React.Element',\n    defaultValue: '<FormDown />'\n  },\n  'dataTable.icons.contract': {\n    description: 'The contract icon.',\n    type: 'React.Element',\n    defaultValue: '<FormUp />'\n  },\n  'dataTable.icons.descending': {\n    description: 'The descending icon.',\n    type: 'React.Element',\n    defaultValue: '<FormUp />'\n  },\n  'dataTable.icons.expand': {\n    description: 'The expand icon.',\n    type: 'React.Element',\n    defaultValue: '<FormDown />'\n  },\n  'dataTable.icons.sortable': {\n    description: 'The icon indicating a column can be sorted.',\n    type: 'React.Element',\n    defaultValue: undefined\n  },\n  'dataTable.pinned.body.background': {\n    description: 'Any valid Box background options apply.',\n    type: \"string | \\n      { dark: string, light: string } |\\n      { \\n        color: { dark: string, light: string } | string, \\n        dark: bool, \\n        image: string, \\n        position: string, \\n        opacity: bool | string, \\n        repeat: no-repeat | repeat, \\n        size: cover | contain | string\\n      }\",\n    defaultValue: undefined\n  },\n  'dataTable.pinned.body.extend': {\n    description: 'Any additional styles for pinned body cells.',\n    type: 'string | (props) => {}',\n    defaultValue: undefined\n  },\n  'dataTable.pinned.header.background': {\n    description: 'Any valid Box background options apply.',\n    type: \"string | \\n      { dark: string, light: string } |\\n      { \\n        color: { dark: string, light: string } | string, \\n        dark: bool, \\n        image: string, \\n        position: string, \\n        opacity: bool | string, \\n        repeat: no-repeat | repeat, \\n        size: cover | contain | string\\n      }\",\n    defaultValue: undefined\n  },\n  'dataTable.pinned.header.extend': {\n    description: 'Any additional styles for pinned header cells.',\n    type: 'string | (props) => {}',\n    defaultValue: undefined\n  },\n  'dataTable.pinned.footer.background': {\n    description: 'Any valid Box background options apply.',\n    type: \"string | \\n      { dark: string, light: string } |\\n      { \\n        color: { dark: string, light: string } | string, \\n        dark: bool, \\n        image: string, \\n        position: string, \\n        opacity: bool | string, \\n        repeat: no-repeat | repeat, \\n        size: cover | contain | string\\n      }\",\n    defaultValue: undefined\n  },\n  'dataTable.pinned.footer.extend': {\n    description: 'Any additional styles for pinned footer cells.',\n    type: 'string | (props) => {}',\n    defaultValue: undefined\n  },\n  'dataTable.primary.weight': {\n    description: 'The font weight for primary cells.',\n    type: 'string',\n    defaultValue: 'bold'\n  },\n  'dataTable.resize.border.color': {\n    description: 'The border color for resize.',\n    type: 'string | { dark: string, light: string }',\n    defaultValue: 'border'\n  },\n  'dataTable.resize.border.side': {\n    description: 'The border side used for resize.',\n    type: 'string',\n    defaultValue: 'right'\n  },\n  'table.row.hover.background': {\n    description: 'The background color when hovering over an interactive row.',\n    type: 'string | { color: string, opacity: string }'\n  },\n  'table.row.hover.color': {\n    description: 'The text color when hovering over an interactive row.',\n    type: 'string | { dark: string, light: string }'\n  }\n};","map":null,"metadata":{},"sourceType":"module"}