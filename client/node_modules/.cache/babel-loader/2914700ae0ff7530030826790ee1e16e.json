{"ast":null,"code":"function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport React, { forwardRef, useCallback, useContext, useMemo, useRef, useState, useEffect } from 'react';\nimport { ThemeContext } from 'styled-components';\nimport { defaultProps } from '../../default-props';\nimport { Box } from '../Box';\nimport { Button } from '../Button';\nimport { Heading } from '../Heading';\nimport { Keyboard } from '../Keyboard';\nimport { StyledCalendar, StyledDay, StyledDayContainer, StyledWeek, StyledWeeks, StyledWeeksContainer } from './StyledCalendar';\nimport { addDays, addMonths, betweenDates, daysApart, endOfMonth, formatToLocalYYYYMMDD, localTimezoneToUTC, startOfMonth, subtractDays, subtractMonths, withinDates } from './utils';\nvar headingPadMap = {\n  small: 'xsmall',\n  medium: 'small',\n  large: 'medium'\n};\nvar activeDates = {\n  start: 'start',\n  end: 'end'\n};\nvar timeStamp = new RegExp(/T.*/);\n\nvar normalizeForTimezone = function normalizeForTimezone(date, refDate) {\n  if (!date) return undefined;\n  return (!timeStamp.test(refDate || date) ? localTimezoneToUTC(new Date(date)) : new Date(date)).toISOString();\n};\n\nvar normalizeReference = function normalizeReference(reference, date, dates) {\n  var normalizedReference;\n\n  if (reference) {\n    normalizedReference = new Date(reference);\n  } else if (date) {\n    normalizedReference = new Date(date);\n  } else if (dates && dates.length > 0) {\n    if (typeof dates[0] === 'string') {\n      normalizedReference = new Date(dates[0]);\n    } else if (Array.isArray(dates[0])) {\n      normalizedReference = new Date(dates[0][0] ? dates[0][0] : dates[0][1]);\n    } else {\n      normalizedReference = new Date();\n      normalizedReference.setHours(0, 0, 0, 0);\n    }\n  } else {\n    normalizedReference = new Date();\n    normalizedReference.setHours(0, 0, 0, 0);\n  }\n\n  return normalizedReference;\n};\n\nvar buildDisplayBounds = function buildDisplayBounds(reference, firstDayOfWeek) {\n  var start = new Date(reference);\n  start.setDate(1); // first of month\n  // In case Sunday is the first day of the month, and the user asked for Monday\n  // to be the first day of the week, then we need to include Sunday and six\n  // days prior.\n\n  start = start.getDay() === 0 && firstDayOfWeek === 1 ? start = subtractDays(start, 6) : // beginning of week\n  start = subtractDays(start, start.getDay() - firstDayOfWeek);\n  var end = addDays(start, 7 * 5 + 7); // 5 weeks to end of week\n\n  return [start, end];\n};\n\nvar millisecondsPerYear = 31557600000;\n\nvar CalendarDayButton = function CalendarDayButton(props) {\n  return /*#__PURE__*/React.createElement(Button, _extends({\n    tabIndex: -1,\n    plain: true\n  }, props));\n};\n\nvar CalendarDay = function CalendarDay(_ref) {\n  var children = _ref.children,\n      fill = _ref.fill,\n      size = _ref.size,\n      isInRange = _ref.isInRange,\n      isSelected = _ref.isSelected,\n      otherMonth = _ref.otherMonth,\n      _ref$buttonProps = _ref.buttonProps,\n      buttonProps = _ref$buttonProps === void 0 ? {} : _ref$buttonProps;\n  return /*#__PURE__*/React.createElement(StyledDayContainer, {\n    sizeProp: size,\n    fillContainer: fill\n  }, /*#__PURE__*/React.createElement(CalendarDayButton, _extends({\n    fill: fill\n  }, buttonProps), /*#__PURE__*/React.createElement(StyledDay, {\n    disabledProp: buttonProps.disabled,\n    inRange: isInRange,\n    otherMonth: otherMonth,\n    isSelected: isSelected,\n    sizeProp: size,\n    fillContainer: fill\n  }, children)));\n};\n\nvar CalendarCustomDay = function CalendarCustomDay(_ref2) {\n  var children = _ref2.children,\n      fill = _ref2.fill,\n      size = _ref2.size,\n      buttonProps = _ref2.buttonProps;\n\n  if (!buttonProps) {\n    return /*#__PURE__*/React.createElement(StyledDayContainer, {\n      sizeProp: size,\n      fillContainer: fill\n    }, children);\n  }\n\n  return /*#__PURE__*/React.createElement(StyledDayContainer, {\n    sizeProp: size,\n    fillContainer: fill\n  }, /*#__PURE__*/React.createElement(CalendarDayButton, _extends({\n    fill: fill\n  }, buttonProps), children));\n};\n\nvar Calendar = /*#__PURE__*/forwardRef(function (_ref3, ref) {\n  var activeDateProp = _ref3.activeDate,\n      _ref3$animate = _ref3.animate,\n      animate = _ref3$animate === void 0 ? true : _ref3$animate,\n      boundsProp = _ref3.bounds,\n      children = _ref3.children,\n      dateProp = _ref3.date,\n      datesProp = _ref3.dates,\n      daysOfWeek = _ref3.daysOfWeek,\n      disabled = _ref3.disabled,\n      fill = _ref3.fill,\n      _ref3$firstDayOfWeek = _ref3.firstDayOfWeek,\n      firstDayOfWeek = _ref3$firstDayOfWeek === void 0 ? 0 : _ref3$firstDayOfWeek,\n      header = _ref3.header,\n      _ref3$locale = _ref3.locale,\n      locale = _ref3$locale === void 0 ? 'en-US' : _ref3$locale,\n      onReference = _ref3.onReference,\n      onSelect = _ref3.onSelect,\n      range = _ref3.range,\n      referenceProp = _ref3.reference,\n      _ref3$showAdjacentDay = _ref3.showAdjacentDays,\n      showAdjacentDays = _ref3$showAdjacentDay === void 0 ? true : _ref3$showAdjacentDay,\n      _ref3$size = _ref3.size,\n      size = _ref3$size === void 0 ? 'medium' : _ref3$size,\n      rest = _objectWithoutPropertiesLoose(_ref3, [\"activeDate\", \"animate\", \"bounds\", \"children\", \"date\", \"dates\", \"daysOfWeek\", \"disabled\", \"fill\", \"firstDayOfWeek\", \"header\", \"locale\", \"onReference\", \"onSelect\", \"range\", \"reference\", \"showAdjacentDays\", \"size\"]);\n\n  var theme = useContext(ThemeContext) || defaultProps.theme; // set activeDate when caller changes it, allows us to change\n  // it internally too\n\n  var _useState = useState(dateProp && range ? activeDates.end : activeDates.start),\n      activeDate = _useState[0],\n      setActiveDate = _useState[1];\n\n  useEffect(function () {\n    if (activeDateProp) setActiveDate(activeDateProp);\n  }, [activeDateProp]); // set date when caller changes it, allows us to change it internally too\n\n  var _useState2 = useState(dateProp),\n      date = _useState2[0],\n      setDate = _useState2[1];\n\n  useEffect(function () {\n    return setDate(normalizeForTimezone(dateProp));\n  }, [dateProp]); // set dates when caller changes it, allows us to change it internally too\n\n  var _useState3 = useState(datesProp),\n      dates = _useState3[0],\n      setDates = _useState3[1];\n\n  useEffect(function () {\n    // convert all values to UTC\n    if (Array.isArray(datesProp)) {\n      if (Array.isArray(datesProp[0])) {\n        var from;\n        var to;\n\n        var _datesProp$0$map = datesProp[0].map(function (day) {\n          return day ? new Date(day) : undefined;\n        });\n\n        from = _datesProp$0$map[0];\n        to = _datesProp$0$map[1];\n        if (from) from = normalizeForTimezone(from, datesProp[0][0]);\n        if (to) to = normalizeForTimezone(to, datesProp[0][0]);\n        setDates([[from, to]]);\n      } else {\n        var datesArray = [];\n        datesProp.forEach(function (d) {\n          if (Array.isArray(d)) {\n            var _from;\n\n            var _to;\n\n            var _d$map = d.map(function (day) {\n              return new Date(day);\n            });\n\n            _from = _d$map[0];\n            _to = _d$map[1];\n            _from = normalizeForTimezone(_from, d[0]);\n            _to = normalizeForTimezone(_to, d[0]);\n            datesArray.push([_from, _to]);\n          } else {\n            datesArray.push(normalizeForTimezone(d));\n          }\n        });\n        setDates(datesArray);\n      }\n    } else setDates(undefined);\n  }, [datesProp]); // set reference based on what the caller passed or date/dates.\n\n  var _useState4 = useState(normalizeReference(referenceProp, date, dates)),\n      reference = _useState4[0],\n      setReference = _useState4[1];\n\n  useEffect(function () {\n    return setReference(normalizeReference(referenceProp, dateProp, datesProp));\n  }, [dateProp, datesProp, referenceProp]); // normalize bounds\n\n  var _useState5 = useState(boundsProp ? boundsProp.map(function (b) {\n    return normalizeForTimezone(b);\n  }) : undefined),\n      bounds = _useState5[0],\n      setBounds = _useState5[1];\n\n  useEffect(function () {\n    if (boundsProp) setBounds(boundsProp.map(function (b) {\n      return normalizeForTimezone(b);\n    }));else setBounds(undefined);\n  }, [boundsProp]); // calculate the bounds we display based on the reference\n\n  var _useState6 = useState(buildDisplayBounds(reference, firstDayOfWeek)),\n      displayBounds = _useState6[0],\n      setDisplayBounds = _useState6[1];\n\n  var _useState7 = useState(),\n      targetDisplayBounds = _useState7[0],\n      setTargetDisplayBounds = _useState7[1];\n\n  var _useState8 = useState(),\n      slide = _useState8[0],\n      setSlide = _useState8[1];\n\n  var _useState9 = useState(),\n      animating = _useState9[0],\n      setAnimating = _useState9[1]; // When the reference changes, we need to update the displayBounds.\n  // This is easy when we aren't animating. If we are animating,\n  // we temporarily increase the displayBounds to be the union of the old\n  // and new ones and set slide to drive the animation. We keep track\n  // of where we are heading via targetDisplayBounds. When the animation\n  // finishes, we prune displayBounds down to where we are headed and\n  // clear the slide and targetDisplayBounds.\n\n\n  useEffect(function () {\n    var nextDisplayBounds = buildDisplayBounds(reference, firstDayOfWeek); // Checks if the difference between the current and next DisplayBounds is\n    // greater than a year. If that's the case, calendar should update without\n    // animation.\n\n    if (nextDisplayBounds[0].getTime() !== displayBounds[0].getTime() && nextDisplayBounds[1].getTime() !== displayBounds[1].getTime()) {\n      var diffBoundsAboveYear = false;\n\n      if (nextDisplayBounds[0].getTime() < displayBounds[0].getTime()) {\n        if (displayBounds[0].getTime() - nextDisplayBounds[0].getTime() > millisecondsPerYear) {\n          diffBoundsAboveYear = true;\n        }\n      } else if (nextDisplayBounds[1].getTime() > displayBounds[1].getTime()) {\n        if (nextDisplayBounds[1].getTime() - displayBounds[1].getTime() > millisecondsPerYear) {\n          diffBoundsAboveYear = true;\n        }\n      }\n\n      if (!animate || diffBoundsAboveYear) {\n        setDisplayBounds(nextDisplayBounds);\n      } else {\n        setTargetDisplayBounds(nextDisplayBounds);\n      }\n    }\n  }, [animate, firstDayOfWeek, reference, displayBounds]);\n  useEffect(function () {\n    if (targetDisplayBounds) {\n      if (targetDisplayBounds[0].getTime() < displayBounds[0].getTime()) {\n        // only animate if the duration is within a year\n        if (displayBounds[0].getTime() - targetDisplayBounds[0].getTime() < millisecondsPerYear) {\n          setDisplayBounds([targetDisplayBounds[0], displayBounds[1]]);\n          setSlide({\n            direction: 'down',\n            weeks: daysApart(displayBounds[0], targetDisplayBounds[0]) / 7\n          });\n          setAnimating(true);\n        }\n      } else if (targetDisplayBounds[1].getTime() > displayBounds[1].getTime()) {\n        if (targetDisplayBounds[1].getTime() - displayBounds[1].getTime() < millisecondsPerYear) {\n          setDisplayBounds([displayBounds[0], targetDisplayBounds[1]]);\n          setSlide({\n            direction: 'up',\n            weeks: daysApart(targetDisplayBounds[1], displayBounds[1]) / 7\n          });\n          setAnimating(true);\n        }\n      }\n\n      return undefined;\n    }\n\n    setSlide(undefined);\n    return undefined;\n  }, [animating, displayBounds, targetDisplayBounds]); // Last step in updating the displayBounds. Allows for pruning\n  // displayBounds and cleaning up states to occur after animation.\n\n  useEffect(function () {\n    if (animating && targetDisplayBounds) {\n      // Wait for animation to finish before cleaning up.\n      var timer = setTimeout(function () {\n        setDisplayBounds(targetDisplayBounds);\n        setTargetDisplayBounds(undefined);\n        setSlide(undefined);\n        setAnimating(false);\n      }, 400 // Empirically determined.\n      );\n      return function () {\n        return clearTimeout(timer);\n      };\n    }\n\n    return undefined;\n  }, [animating, targetDisplayBounds]); // We have to deal with reference being the end of a month with more\n  // days than the month we are changing to. So, we always set reference\n  // to the first of the month before changing the month.\n\n  var previousMonth = useMemo(function () {\n    return endOfMonth(subtractMonths(startOfMonth(reference), 1));\n  }, [reference]);\n  var nextMonth = useMemo(function () {\n    return startOfMonth(addMonths(startOfMonth(reference), 1));\n  }, [reference]);\n  var daysRef = useRef();\n\n  var _useState10 = useState(),\n      focus = _useState10[0],\n      setFocus = _useState10[1];\n\n  var _useState11 = useState(),\n      active = _useState11[0],\n      setActive = _useState11[1];\n\n  var changeReference = useCallback(function (nextReference) {\n    if (betweenDates(nextReference, bounds)) {\n      setReference(nextReference);\n      if (onReference) onReference(nextReference.toISOString());\n    }\n  }, [onReference, bounds]);\n  var selectDate = useCallback(function (selectedDate) {\n    var nextDates;\n    var nextDate; // output date with no timestamp if that's how user provided it\n\n    var adjustedDate;\n\n    if (!range) {\n      nextDate = selectedDate;\n\n      if (datesProp) {\n        datesProp.forEach(function (d) {\n          if (!timeStamp.test(d)) {\n            adjustedDate = formatToLocalYYYYMMDD(nextDate);\n\n            if (d === adjustedDate) {\n              nextDate = undefined;\n            } else {\n              adjustedDate = undefined;\n            }\n          }\n        });\n      } else if (dateProp) {\n        if (!timeStamp.test(dateProp)) {\n          adjustedDate = formatToLocalYYYYMMDD(selectedDate);\n\n          if (dateProp === adjustedDate) {\n            nextDate = undefined;\n          } else {\n            adjustedDate = undefined;\n          }\n        } else {\n          adjustedDate = undefined;\n        }\n      }\n    } // everything down is a range\n    else if (!dates) {\n        // if user supplies date, convert this into dates\n        if (date) {\n          var priorDate = new Date(date);\n          var selDate = new Date(selectedDate);\n\n          if (activeDate === activeDates.start) {\n            if (selDate.getTime() > priorDate.getTime()) {\n              nextDates = [[selectedDate, undefined]];\n            } else {\n              nextDates = [[selectedDate, date]];\n            }\n\n            setActiveDate(activeDates.end);\n            if (activeDateProp) setActiveDate(activeDateProp);\n          } else if (activeDate === activeDates.end) {\n            if (selDate.getTime() < priorDate.getTime()) {\n              nextDates = [[selectedDate, undefined]];\n              setActiveDate(activeDates.end);\n            } else {\n              nextDates = [[date, selectedDate]];\n              setActiveDate(activeDates.start);\n            }\n\n            if (activeDateProp) setActiveDate(activeDateProp);\n          }\n        } else if (activeDate === activeDates.start) {\n          nextDates = [[selectedDate, undefined]];\n          setActiveDate(activeDates.end);\n        } else if (activeDate === activeDates.end) {\n          nextDates = [[undefined, selectedDate]];\n        }\n\n        if (activeDateProp) setActiveDate(activeDateProp);\n      } else {\n        // have dates\n        var priorDates = dates[0].map(function (d) {\n          return new Date(d);\n        });\n\n        var _selDate = new Date(selectedDate);\n\n        if (_selDate.getTime() === priorDates[0].getTime()) {\n          nextDates = [[undefined, dates[0][1]]];\n          setActiveDate(activeDates.start);\n        } else if (_selDate.getTime() === priorDates[1].getTime()) {\n          nextDates = [[dates[0][0], undefined]];\n          setActiveDate(activeDates.end);\n          if (activeDateProp) setActiveDate(activeDateProp);\n        } else if (activeDate === activeDates.start) {\n          if (_selDate.getTime() > priorDates[1].getTime()) {\n            nextDates = [[selectedDate, undefined]];\n          } else {\n            nextDates = [[selectedDate, dates[0][1]]];\n          }\n\n          setActiveDate(activeDates.end);\n          if (activeDateProp) setActiveDate(activeDateProp);\n        } else if (activeDate === activeDates.end) {\n          if (_selDate.getTime() < priorDates[0].getTime()) {\n            nextDates = [[selectedDate, undefined]];\n            setActiveDate(activeDates.end);\n          } else {\n            nextDates = [[dates[0][0], selectedDate]];\n            setActiveDate(activeDates.start);\n          }\n\n          if (activeDateProp) setActiveDate(activeDateProp);\n        } // cleanup\n\n\n        if (!nextDates[0][0] && !nextDates[0][1]) nextDates = undefined;\n      }\n\n    setDates(nextDates);\n    if (!dates) setDate(nextDate);\n    setActive(new Date(selectedDate));\n\n    if (onSelect) {\n      var adjustedDates;\n\n      if (nextDates && Array.isArray(nextDates[0]) && (!nextDates[0][0] || !nextDates[0][1]) && range === true) {\n        // return string for backwards compatibility\n        var _nextDates$0$filter = nextDates[0].filter(function (d) {\n          return d;\n        });\n\n        adjustedDates = _nextDates$0$filter[0];\n      } else {\n        adjustedDates = nextDates;\n      }\n\n      onSelect(adjustedDates || adjustedDate || nextDate);\n    }\n  }, [activeDate, activeDateProp, date, dateProp, dates, datesProp, onSelect, range]);\n\n  var renderCalendarHeader = function renderCalendarHeader() {\n    var PreviousIcon = size === 'small' ? theme.calendar.icons.small.previous : theme.calendar.icons.previous;\n    var NextIcon = size === 'small' ? theme.calendar.icons.small.next : theme.calendar.icons.next;\n    return /*#__PURE__*/React.createElement(Box, {\n      direction: \"row\",\n      justify: \"between\",\n      align: \"center\"\n    }, /*#__PURE__*/React.createElement(Box, {\n      flex: true,\n      pad: {\n        horizontal: headingPadMap[size] || 'small'\n      }\n    }, /*#__PURE__*/React.createElement(Heading, {\n      level: size === 'small' ? theme.calendar.heading && theme.calendar.heading.level || 4 : (theme.calendar.heading && theme.calendar.heading.level || 4) - 1,\n      size: size,\n      margin: \"none\"\n    }, reference.toLocaleDateString(locale, {\n      month: 'long',\n      year: 'numeric'\n    }))), /*#__PURE__*/React.createElement(Box, {\n      flex: false,\n      direction: \"row\",\n      align: \"center\"\n    }, /*#__PURE__*/React.createElement(Button, {\n      a11yTitle: previousMonth.toLocaleDateString(locale, {\n        month: 'long',\n        year: 'numeric'\n      }),\n      icon: /*#__PURE__*/React.createElement(PreviousIcon, {\n        size: size !== 'small' ? size : undefined\n      }),\n      disabled: !betweenDates(previousMonth, bounds),\n      onClick: function onClick() {\n        return changeReference(previousMonth);\n      }\n    }), /*#__PURE__*/React.createElement(Button, {\n      a11yTitle: nextMonth.toLocaleDateString(locale, {\n        month: 'long',\n        year: 'numeric'\n      }),\n      icon: /*#__PURE__*/React.createElement(NextIcon, {\n        size: size !== 'small' ? size : undefined\n      }),\n      disabled: !betweenDates(nextMonth, bounds),\n      onClick: function onClick() {\n        return changeReference(nextMonth);\n      }\n    })));\n  };\n\n  var renderDaysOfWeek = function renderDaysOfWeek() {\n    var day = new Date(displayBounds[0]);\n    var days = [];\n\n    while (days.length < 7) {\n      days.push( /*#__PURE__*/React.createElement(StyledDayContainer, {\n        key: days.length,\n        sizeProp: size,\n        fillContainer: fill\n      }, /*#__PURE__*/React.createElement(StyledDay, {\n        otherMonth: true,\n        sizeProp: size,\n        fillContainer: fill\n      }, day.toLocaleDateString(locale, {\n        weekday: 'narrow'\n      }))));\n      day = addDays(day, 1);\n    }\n\n    return /*#__PURE__*/React.createElement(StyledWeek, null, days);\n  };\n\n  var weeks = [];\n  var day = new Date(displayBounds[0]);\n  var days;\n  var firstDayInMonth;\n\n  while (day.getTime() < displayBounds[1].getTime()) {\n    if (day.getDay() === firstDayOfWeek) {\n      if (days) {\n        weeks.push( /*#__PURE__*/React.createElement(StyledWeek, {\n          key: day.getTime(),\n          fillContainer: fill\n        }, days));\n      }\n\n      days = [];\n    }\n\n    var otherMonth = day.getMonth() !== reference.getMonth();\n\n    if (!showAdjacentDays && otherMonth) {\n      days.push( /*#__PURE__*/React.createElement(StyledDayContainer, {\n        key: day.getTime(),\n        sizeProp: size,\n        fillContainer: fill\n      }, /*#__PURE__*/React.createElement(StyledDay, {\n        sizeProp: size,\n        fillContainer: fill\n      })));\n    } else if (\n    /* Do not show adjacent days in 6th row if all days \n    fall in the next month */\n    showAdjacentDays === 'trim' && otherMonth && weeks.length === 5 &&\n    /* If the length days array is less than the current getDate()\n    we know that all days in the array are from the next month. */\n    days.length < day.getDate()) {\n      days.push( /*#__PURE__*/React.createElement(StyledDayContainer, {\n        key: day.getTime(),\n        sizeProp: size,\n        fillContainer: fill\n      }, /*#__PURE__*/React.createElement(StyledDay, {\n        sizeProp: size,\n        fillContainer: fill\n      })));\n    } else {\n      (function () {\n        var dateString = day.toISOString(); // this.dayRefs[dateString] = React.createRef();\n\n        var selected = false;\n        var inRange = false;\n        var selectedState = withinDates(day, date || dates);\n\n        if (selectedState === 2) {\n          selected = true;\n        } else if (selectedState === 1) {\n          inRange = true;\n        }\n\n        var dayDisabled = withinDates(day, disabled) || bounds && !betweenDates(day, bounds);\n\n        if (!firstDayInMonth && !dayDisabled && day.getMonth() === reference.getMonth()) {\n          firstDayInMonth = dateString;\n        }\n\n        if (!children) {\n          days.push( /*#__PURE__*/React.createElement(CalendarDay, {\n            key: day.getTime(),\n            buttonProps: {\n              a11yTitle: day.toDateString(),\n              active: active && active.getTime() === day.getTime(),\n              disabled: dayDisabled && !!dayDisabled,\n              onClick: function onClick() {\n                selectDate(dateString); // Chrome moves the focus indicator to this button. Set\n                // the focus to the grid of days instead.\n\n                daysRef.current.focus();\n              },\n              onMouseOver: function onMouseOver() {\n                return setActive(new Date(dateString));\n              },\n              onMouseOut: function onMouseOut() {\n                return setActive(undefined);\n              }\n            },\n            isInRange: inRange,\n            isSelected: selected,\n            otherMonth: day.getMonth() !== reference.getMonth(),\n            size: size,\n            fill: fill\n          }, day.getDate()));\n        } else {\n          days.push( /*#__PURE__*/React.createElement(CalendarCustomDay, {\n            key: day.getTime(),\n            buttonProps: onSelect ? {\n              a11yTitle: day.toDateString(),\n              active: active && active.getTime() === day.getTime(),\n              disabled: dayDisabled && !!dayDisabled,\n              onClick: function onClick() {\n                selectDate(dateString); // Chrome moves the focus indicator to this button. Set\n                // the focus to the grid of days instead.\n\n                daysRef.current.focus();\n              },\n              onMouseOver: function onMouseOver() {\n                return setActive(new Date(dateString));\n              },\n              onMouseOut: function onMouseOut() {\n                return setActive(undefined);\n              }\n            } : null,\n            size: size,\n            fill: fill\n          }, children({\n            date: day,\n            day: day.getDate(),\n            isInRange: inRange,\n            isSelected: selected\n          })));\n        }\n      })();\n    }\n\n    day = addDays(day, 1);\n  }\n\n  weeks.push( /*#__PURE__*/React.createElement(StyledWeek, {\n    key: day.getTime(),\n    fillContainer: fill\n  }, days));\n  return /*#__PURE__*/React.createElement(StyledCalendar, _extends({\n    ref: ref,\n    sizeProp: size,\n    fillContainer: fill\n  }, rest), /*#__PURE__*/React.createElement(Box, {\n    fill: fill\n  }, header ? header({\n    date: reference,\n    locale: locale,\n    onPreviousMonth: function onPreviousMonth() {\n      return changeReference(previousMonth);\n    },\n    onNextMonth: function onNextMonth() {\n      return changeReference(nextMonth);\n    },\n    previousInBound: betweenDates(previousMonth, bounds),\n    nextInBound: betweenDates(nextMonth, bounds)\n  }) : renderCalendarHeader(previousMonth, nextMonth), daysOfWeek && renderDaysOfWeek(), /*#__PURE__*/React.createElement(Keyboard, {\n    onEnter: function onEnter() {\n      return selectDate(active.toISOString());\n    },\n    onUp: function onUp(event) {\n      event.preventDefault();\n      event.stopPropagation(); // so the page doesn't scroll\n\n      setActive(addDays(active, -7));\n    },\n    onDown: function onDown(event) {\n      event.preventDefault();\n      event.stopPropagation(); // so the page doesn't scroll\n\n      setActive(addDays(active, 7));\n    },\n    onLeft: function onLeft() {\n      return active && setActive(addDays(active, -1));\n    },\n    onRight: function onRight() {\n      return active && setActive(addDays(active, 1));\n    }\n  }, /*#__PURE__*/React.createElement(StyledWeeksContainer, {\n    ref: daysRef,\n    sizeProp: size,\n    fillContainer: fill,\n    tabIndex: 0,\n    focus: focus,\n    onFocus: function onFocus() {\n      setFocus(true);\n\n      if (date && betweenDates(new Date(date), displayBounds)) {\n        setActive(new Date(date));\n      } else {\n        setActive(new Date(firstDayInMonth));\n      }\n    },\n    onBlur: function onBlur() {\n      setFocus(false);\n      setActive(undefined);\n    }\n  }, /*#__PURE__*/React.createElement(StyledWeeks, {\n    slide: slide,\n    sizeProp: size,\n    fillContainer: fill\n  }, weeks)))));\n});\nCalendar.displayName = 'Calendar';\nvar CalendarDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  CalendarDoc = require('./doc').doc(Calendar);\n}\n\nvar CalendarWrapper = CalendarDoc || Calendar;\nexport { CalendarWrapper as Calendar };","map":null,"metadata":{},"sourceType":"module"}