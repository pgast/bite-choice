{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.themeDoc = exports.doc = exports.OVERFLOW_VALUES = void 0;\n\nvar _reactDesc = require(\"react-desc\");\n\nvar _utils = require(\"../../utils\");\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar OVERFLOW_VALUES = ['auto', 'hidden', 'scroll', 'visible'];\nexports.OVERFLOW_VALUES = OVERFLOW_VALUES;\n\nvar ANIMATION_TYPE = _reactDesc.PropTypes.oneOf(['fadeIn', 'fadeOut', 'jiggle', 'pulse', 'slideUp', 'slideDown', 'slideLeft', 'slideRight', 'zoomIn', 'zoomOut']);\n\nvar ANIMATION_SHAPE = _reactDesc.PropTypes.shape({\n  type: ANIMATION_TYPE,\n  delay: _reactDesc.PropTypes.number,\n  duration: _reactDesc.PropTypes.number,\n  size: _reactDesc.PropTypes.oneOf(['xsmall', 'small', 'medium', 'large', 'xlarge'])\n});\n\nvar BORDER_SHAPE = _reactDesc.PropTypes.shape({\n  color: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.string, _reactDesc.PropTypes.shape({\n    dark: _reactDesc.PropTypes.string,\n    light: _reactDesc.PropTypes.string\n  })]),\n  side: _reactDesc.PropTypes.oneOf(['top', 'left', 'bottom', 'right', 'start', 'end', 'horizontal', 'vertical', 'all', 'between']),\n  size: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['xsmall', 'small', 'medium', 'large', 'xlarge']), _reactDesc.PropTypes.string]),\n  style: _reactDesc.PropTypes.oneOf(['solid', 'dashed', 'dotted', 'double', 'groove', 'ridge', 'inset', 'outset', 'hidden']).defaultValue('solid')\n}); // if you update values here, make sure to update in Drop/doc too.\n\n\nvar overflowPropType = _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(OVERFLOW_VALUES), _reactDesc.PropTypes.shape({\n  horizontal: _reactDesc.PropTypes.oneOf(OVERFLOW_VALUES),\n  vertical: _reactDesc.PropTypes.oneOf(OVERFLOW_VALUES)\n}), _reactDesc.PropTypes.string]);\n\nvar doc = function doc(Box) {\n  var DocumentedBox = (0, _reactDesc.describe)(Box).availableAt((0, _utils.getAvailableAtBadge)('Box')).description(\"A container that lays out its contents in one direction. Box\\n      provides CSS flexbox capabilities for layout, as well as general\\n      styling of things like background color, border, and animation.\").usage(\"import { Box } from 'grommet';\\n<Box />\").intrinsicElement('div');\n  DocumentedBox.propTypes = _extends({}, _utils.genericProps, {\n    align: _reactDesc.PropTypes.oneOf(['start', 'center', 'end', 'baseline', 'stretch']).description('How to align the contents along the cross axis.'),\n    alignContent: _reactDesc.PropTypes.oneOf(['start', 'center', 'end', 'between', 'around', 'stretch']).description(\"How to align the contents when there is extra space in\\n        the cross axis.\").defaultValue('stretch'),\n    animation: _reactDesc.PropTypes.oneOfType([ANIMATION_TYPE, ANIMATION_SHAPE, _reactDesc.PropTypes.arrayOf(_reactDesc.PropTypes.oneOfType([ANIMATION_TYPE, ANIMATION_SHAPE]))]).description(\"Animation effect(s) to use. 'duration' and 'delay' should\\n        be in milliseconds. 'jiggle' and 'pulse' types are intended for\\n        small elements, like icons.\"),\n    background: _utils.backgroundDoc,\n    basis: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['xxsmall', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'xxlarge', 'full', '1/2', '1/3', '2/3', '1/4', '2/4', '3/4', 'auto']), _reactDesc.PropTypes.string]).description(\"A fixed or relative size along its container's main axis.\"),\n    border: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.bool, _reactDesc.PropTypes.oneOf(['top', 'left', 'bottom', 'right', 'start', 'end', 'horizontal', 'vertical', 'all', 'between']), BORDER_SHAPE, _reactDesc.PropTypes.arrayOf(BORDER_SHAPE)]).description(\"Include a border. 'between' will place a border in the gap between\\n      child elements. You must have a 'gap' to use 'between'.\"),\n    direction: _reactDesc.PropTypes.oneOf(['row', 'column', 'row-responsive', 'row-reverse', 'column-reverse']).description('The orientation to layout the child components in.').defaultValue('column'),\n    elevation: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['none', 'xsmall', 'small', 'medium', 'large', 'xlarge']), _reactDesc.PropTypes.string]).description(\"Elevated height above the underlying context, indicated\\n        via a drop shadow.\").defaultValue('none'),\n    flex: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['grow', 'shrink']), _reactDesc.PropTypes.bool, _reactDesc.PropTypes.shape({\n      grow: _reactDesc.PropTypes.number,\n      shrink: _reactDesc.PropTypes.number\n    })]).description('Whether flex-grow and/or flex-shrink is true and at a desired factor.'),\n    fill: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['horizontal', 'vertical']), _reactDesc.PropTypes.bool]).description('Whether the width and/or height should fill the container.'),\n    focusIndicator: _reactDesc.PropTypes.bool.description(\"When interactive via 'onClick', whether it should receive a focus\\n        outline.\").defaultValue(true),\n    gap: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['none', 'xxsmall', 'xsmall', 'small', 'medium', 'large', 'xlarge']), _reactDesc.PropTypes.string]).description(\"The amount of spacing between child elements. This\\n        should not be used in conjunction with 'wrap' as the gap elements\\n        will not wrap gracefully.\"),\n    height: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['xxsmall', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'xxlarge']), _reactDesc.PropTypes.string, _reactDesc.PropTypes.shape({\n      min: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['xxsmall', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'xxlarge']), _reactDesc.PropTypes.string]),\n      max: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['xxsmall', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'xxlarge']), _reactDesc.PropTypes.string])\n    })]).description('A fixed height.'),\n    hoverIndicator: _utils.hoverIndicatorPropType.description(\"When 'onClick' has been specified, the hover indicator to apply\\n        when the user is mousing over the box.\").defaultValue(false),\n    justify: _reactDesc.PropTypes.oneOf(['around', 'between', 'center', 'end', 'evenly', 'start', 'stretch']).description('How to align the contents along the main axis.').defaultValue('stretch'),\n    onClick: _reactDesc.PropTypes.func.description(\"Click handler. Setting this property adds additional attributes to\\n      the DOM for accessibility.\"),\n    overflow: overflowPropType.description('box overflow.'),\n    pad: _utils.padPropType,\n    responsive: _reactDesc.PropTypes.bool.description(\"Whether margin, pad, and border\\n      sizes should be scaled for mobile environments.\").defaultValue(true),\n    round: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.bool, _reactDesc.PropTypes.oneOf(['xsmall', 'small', 'medium', 'large', 'xlarge', 'full']), _reactDesc.PropTypes.string, _reactDesc.PropTypes.shape({\n      corner: _reactDesc.PropTypes.oneOf(['top', 'left', 'bottom', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right']),\n      size: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['xsmall', 'small', 'medium', 'large', 'xlarge']), _reactDesc.PropTypes.string])\n    })]).description('How much to round the corners.').defaultValue(false),\n    tag: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.string, _reactDesc.PropTypes.func]).description(\"The DOM tag to use for the element. NOTE: This is deprecated in favor\\nof indicating the DOM tag via the 'as' property.\"),\n    as: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.string, _reactDesc.PropTypes.func]).description('The DOM tag or react component to use for the element.').defaultValue('div'),\n    width: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['xxsmall', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'xxlarge']), _reactDesc.PropTypes.string, _reactDesc.PropTypes.shape({\n      min: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['xxsmall', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'xxlarge']), _reactDesc.PropTypes.string]),\n      max: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.oneOf(['xxsmall', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'xxlarge']), _reactDesc.PropTypes.string])\n    })]).description('A fixed width.'),\n    wrap: _reactDesc.PropTypes.oneOfType([_reactDesc.PropTypes.bool, _reactDesc.PropTypes.oneOf(['reverse'])]).description(\"Whether children can wrap if they can't all fit.\").defaultValue(false)\n  });\n  return DocumentedBox;\n};\n\nexports.doc = doc;\n\nvar themeDoc = _extends({\n  'global.animation': {\n    description: 'The animation configuration for the Box.',\n    type: 'object',\n    defaultValue: \"{\\n  duration: '1s',\\n  jiggle: {\\n    duration: '0.1s',\\n  },\\n}\"\n  },\n  'global.borderSize': {\n    description: 'The possible border sizes in the Box.',\n    type: 'object',\n    defaultValue: \"{\\n  xsmall: '1px',\\n  small: '2px',\\n  medium: '4px',\\n  large: '12px',\\n  xlarge: '24px,\\n}\"\n  },\n  'global.elevation': {\n    description: 'The possible shadows in Box elevation.',\n    type: 'object',\n    defaultValue: \"{\\n  light: {\\n    none: 'none',\\n    xsmall: '0px 1px 2px rgba(100, 100, 100, 0.50)',\\n    small: '0px 2px 4px rgba(100, 100, 100, 0.50)',\\n    medium: '0px 3px 8px rgba(100, 100, 100, 0.50)',\\n    large: '0px 6px 12px rgba(100, 100, 100, 0.50)',\\n    xlarge: '0px 8px 16px rgba(100, 100, 100, 0.50)',\\n  },\\n  dark: {\\n    none: 'none',\\n    xsmall: '0px 2px 2px rgba(255, 255, 255, 0.40)',\\n    small: '0px 4px 4px rgba(255, 255, 255, 0.40)',\\n    medium: '0px 6px 8px rgba(255, 255, 255, 0.40)',\\n    large: '0px 8px 16px rgba(255, 255, 255, 0.40)',\\n    xlarge: '0px 10px 24px rgba(255, 255, 255, 0.40)',\\n  },\\n}\"\n  },\n  'global.colors.border': {\n    description: 'The color of the border',\n    type: 'string | { dark: string, light: string }',\n    defaultValue: '{ dark: rgba(255, 255, 255, 0.33), light: rgba(0, 0, 0, 0.33), }'\n  },\n  'global.hover.background.color': {\n    description: 'The color of the default background when hovering',\n    type: 'string | { dark: string, light: string }',\n    defaultValue: 'active'\n  },\n  'global.hover.background.opacity': {\n    description: 'The opacity of the default background when hovering',\n    type: 'string | { dark: string, light: string }',\n    defaultValue: 'medium'\n  },\n  'global.hover.color': {\n    description: 'The color of the default background when hovering',\n    type: 'string | { dark: string, light: string }',\n    defaultValue: '{ dark: \"white\", light: \"black\" }'\n  },\n  'global.opacity.medium': {\n    description: 'The value used when background opacity is set to true.',\n    type: 'number',\n    defaultValue: '0.4'\n  },\n  'global.size': {\n    description: 'The possible sizes for width, height, and basis.',\n    type: 'object',\n    defaultValue: \"{\\n  xxsmall: '48px',\\n  xsmall: '96px',\\n  small: '192px',\\n  medium: '384px',\\n  large: '768px',\\n  xlarge: '1152px',\\n  xxlarge: '1536px',\\n  full: '100%',\\n}\"\n  },\n  'box.extend': {\n    description: 'Any additional style for the Box.',\n    type: 'string | (props) => {}',\n    defaultValue: undefined\n  },\n  'box.responsiveBreakpoint': {\n    description: \"The actual breakpoint to trigger changes in the border, \\n    direction, gap, margin, pad, and round.\",\n    type: 'string',\n    defaultValue: 'small'\n  }\n}, _utils.themeDocUtils.edgeStyle('The possible sizes for any of gap, margin, and pad.'), {}, _utils.themeDocUtils.breakpointStyle(\"The possible breakpoints that could affect border, direction, gap, margin, \\n    pad, and round.\"));\n\nexports.themeDoc = themeDoc;","map":null,"metadata":{},"sourceType":"script"}